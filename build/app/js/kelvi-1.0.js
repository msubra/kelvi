// Generated by CoffeeScript 1.6.3
var Dashboard, GlobalConfig, Kelvi, KelviDashboard, KelviTopic, Panel, SYMBOL_CODE_MAP, compareAndCopy, dabba, getConfig, jaadi, loadConfig, saveConfig, toQueryString, updateConfig, _ref,
  __hasProp = {}.hasOwnProperty,
  __extends = function(child, parent) { for (var key in parent) { if (__hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; };

try {
  jaadi = Jaadi.createInstance("localstorage");
} catch (_error) {
  jaadi = Jaadi.createInstance("dom");
}

dabba = jaadi;

GlobalConfig = {
  usertopics: ['java', 'jquery', 'javascript', 'python'],
  useUserSettings: false,
  "default": {
    questionsCount: 8,
    refreshRate: 10 * 60 * 1000,
    watches: {
      "active": {
        "title": "active",
        "category": "active",
        "url": "https://api.stackoverflow.com/1.1/questions",
        "query": {
          "tagged": "__TOPIC__"
        },
        "show": true,
        "enable": true
      },
      "new": {
        "title": "new",
        "category": "new",
        "url": "https://api.stackoverflow.com/1.1/questions",
        "query": {
          "sort": "creation",
          "order": "desc",
          "tagged": "__TOPIC__"
        },
        "show": false,
        "enable": true
      },
      "featured": {
        "title": "featured",
        "category": "featured",
        "url": "https://api.stackoverflow.com/1.1/questions",
        "query": {
          "sort": "featured",
          "order": "asc",
          "tagged": "__TOPIC__"
        },
        "show": false,
        "enable": true
      },
      "unanswered": {
        "title": "unanswered",
        "category": "unanswered",
        "url": "https://api.stackoverflow.com/1.1/questions/no-answers",
        "query": {
          "sort": "votes",
          "order": "desc",
          "tagged": "__TOPIC__",
          "pagesize": 50
        },
        "show": false,
        "enable": true
      }
    }
  },
  topics: {
    java: {
      topic: "java"
    },
    jquery: {
      topic: "jquery"
    },
    javascript: {
      topic: "javascript"
    },
    python: {
      topic: "python"
    }
  }
};

saveConfig = function() {
  return dabba.put("KelviCfg", GlobalConfig);
};

loadConfig = function() {
  var cfg, k, topic, _ref, _results;
  if (dabba.get("KelviCfg") !== null) {
    return GlobalConfig = dabba.get("KelviCfg");
  } else {
    _ref = GlobalConfig.topics;
    _results = [];
    for (k in _ref) {
      topic = _ref[k];
      cfg = getConfig(k);
      _results.push(GlobalConfig.topics[k] = cfg);
    }
    return _results;
  }
};

updateConfig = function(topic) {
  GlobalConfig.topics[topic] = {
    "topic": topic
  };
  GlobalConfig.topics[topic] = getConfig(topic);
  return saveConfig();
};

compareAndCopy = function(target_map, default_map) {
  var k, v;
  for (k in default_map) {
    v = default_map[k];
    if (!(k in target_map)) {
      if (typeof v === "object") {
        target_map[k] = jQuery.extend(true, {}, v);
      } else {
        target_map[k] = v;
      }
    } else {
      if (typeof v === "object") {
        compareAndCopy(target_map[k], v);
      }
    }
  }
  return target_map;
};

getConfig = function(topic) {
  var cfg, cloned_cfg, common_cfg, k, w, _ref;
  common_cfg = GlobalConfig["default"];
  if (topic in GlobalConfig.topics) {
    cfg = GlobalConfig.topics[topic];
    cloned_cfg = jQuery.extend(true, {}, cfg);
    cloned_cfg = compareAndCopy(cloned_cfg, common_cfg);
    _ref = cloned_cfg.watches;
    for (k in _ref) {
      w = _ref[k];
      w.query.tagged = topic;
    }
    return cloned_cfg;
  }
  return common_cfg;
};

loadConfig();

Panel = (function() {
  function Panel(name, settings) {
    this.name = name;
    this.settings = settings;
    this.id = "_pnl_" + this.name;
  }

  Panel.prototype.init = function() {};

  Panel.prototype.update = function() {};

  return Panel;

})();

Dashboard = (function() {
  var panelContainer;

  panelContainer = {};

  function Dashboard(name) {
    this.name = name;
  }

  Dashboard.prototype._addNewPanel = function(name, settings) {
    var newPanel;
    newPanel = new Panel(name, settings);
    return panelContainer[name] = {
      "panel": newPanel,
      "settings": settings || null
    };
  };

  Dashboard.prototype.createPanel = function(name, settings) {
    return this._addNewPanel(name, settings);
  };

  Dashboard.prototype.addPanel = function(panel) {
    return panelContainer[panel.name] = panel;
  };

  Dashboard.prototype.getPanel = function(name) {
    return panelContainer[name] || null;
  };

  Dashboard.prototype.get = function(name) {
    var o, panels;
    if (name === "panels") {
      panels = [];
      for (name in panelContainer) {
        o = panelContainer[name];
        panels.push(o);
      }
      return panels;
    }
    return null;
  };

  return Dashboard;

})();

toQueryString = function(params) {
  var k, qs, v;
  qs = "";
  for (k in params) {
    v = params[k];
    qs += "" + k + "=" + (encodeURIComponent(v)) + "&";
  }
  return qs;
};

KelviDashboard = (function(_super) {
  __extends(KelviDashboard, _super);

  function KelviDashboard() {
    _ref = KelviDashboard.__super__.constructor.apply(this, arguments);
    return _ref;
  }

  return KelviDashboard;

})(Dashboard);

SYMBOL_CODE_MAP = {
  "#": "_hash_",
  "+": "_plus_",
  "-": "_minus_",
  "$": "_dollar_",
  "%": "_percent_",
  ".": "_dot_"
};

/*
Fetch the config for the given topic. If a 'topic' is not found, then return the default settings.
If a topic has its own settings, verify it has all required settings. Any attribute not found, derive it from 'default'
*/


KelviTopic = (function(_super) {
  var fn, hook, hooks;

  __extends(KelviTopic, _super);

  hooks = {
    "dataloadInit": function() {},
    "dataloadComplete": function() {},
    "dataLoader": function() {}
  };

  for (hook in hooks) {
    fn = hooks[hook];
    KelviTopic.prototype[hook] = fn;
  }

  KelviTopic.prototype.watches = function() {
    var k, output, w, _i, _len, _ref1;
    output = [];
    _ref1 = this._watches;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      k = _ref1[_i];
      w = this._watches[k];
      if ("enable" in k && k.enable === false) {
        continue;
      }
      output.push(k);
    }
    return output;
  };

  KelviTopic.prototype.getConfig = function() {
    var cfg, cloned_cfg, common_cfg, k, w, _ref1;
    common_cfg = GlobalConfig["default"];
    if (this.topic in GlobalConfig.topics) {
      cfg = GlobalConfig.topics[this.topic];
      cloned_cfg = jQuery.extend(true, {}, cfg);
      cloned_cfg = compareAndCopy(cloned_cfg, common_cfg);
      _ref1 = cloned_cfg.watches;
      for (k in _ref1) {
        w = _ref1[k];
        w.query.tagged = this.topic;
      }
      return cloned_cfg;
    }
    return common_cfg;
  };

  function KelviTopic(topic, url, count, refresh) {
    var k, v, w;
    this.topic = topic;
    this.count = count;
    this.response = {};
    this.config = this.getConfig();
    this.config.questionsCount = this.count = this.count || this.config.questionsCount;
    this.config.refreshRate = refresh = refresh || this.config.refreshRate;
    console.log(this.config);
    KelviTopic.__super__.constructor.call(this, this.topic, {
      "config": this.config
    });
    w = this.config.watches;
    this._watches = [];
    for (k in w) {
      v = w[k];
      this._watches.push(v);
    }
  }

  KelviTopic.prototype.getURL = function(watchConfig) {
    var qs;
    qs = toQueryString(watchConfig.query);
    return "" + watchConfig.url + "?" + qs;
  };

  KelviTopic.prototype.questions = function(watch) {
    return this.response[watch];
  };

  KelviTopic.prototype.show = function(watchToShow) {
    var w, _i, _len, _ref1, _results;
    _ref1 = this.watches();
    _results = [];
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      w = _ref1[_i];
      if (watchToShow.category === w.category) {
        _results.push(w.show = true);
      } else {
        _results.push(w.show = false);
      }
    }
    return _results;
  };

  KelviTopic.prototype.init = function() {
    /*
    		answer_count: 2
    		community_owned: false
    		creation_date: 1388108504
    		down_vote_count: 0
    		favorite_count: 0
    		last_activity_date: 1388111290
    		last_edit_date: 1388108600
    		owner: Object
    		question_answers_url: "/questions/20793590/answers"
    		question_comments_url: "/questions/20793590/comments"
    		question_id: 20793590
    		question_timeline_url: "/questions/20793590/timeline"
    		score: 0
    		tags: Array[4]
    		title: "Binding json, that has a list, with an object using Jackson"
    		up_vote_count: 0
    		view_count: 9
    */

    var callback_name, transformQuestions, watch, _fn, _i, _len, _ref1,
      _this = this;
    transformQuestions = function(data) {
      var qn, questions, _i, _len, _ref1;
      questions = [];
      _ref1 = data['questions'];
      for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
        qn = _ref1[_i];
        if ('closed_reason' in qn) {
          continue;
        }
        questions.push({
          question_id: qn.question_id,
          title: qn.title,
          url: qn.question_answers_url,
          up_vote: qn.up_vote_count,
          down_vote: qn.down_vote_count,
          answers: qn.answer_count,
          bounty: ('bounty_closes_date' in qn) && qn.bounty_closes_date * 1000 <= new Date().getTime() && ('bounty_amount' in qn) ? qn.bounty_amount : null
        });
        if (questions.length >= _this.count) {
          break;
        }
      }
      return questions;
    };
    _ref1 = this._watches;
    _fn = function(callback_name, watch, response, dataloadComplete) {
      _this.response = response;
      _this.dataloadComplete = dataloadComplete;
      console.log("creating " + callback_name);
      return window[callback_name] = function(data) {
        if (_this.dataloadComplete && typeof _this.dataloadComplete === 'function') {
          _this.dataloadComplete();
        }
        response[watch.category] = transformQuestions(data);
      };
    };
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      watch = _ref1[_i];
      if (!watch.enable === true) {
        continue;
      }
      callback_name = "callback_" + (this.encodedCallbackName()) + "_" + watch.category;
      _fn(callback_name, watch, this.response, this.dataloadComplete);
    }
    return (function(_this, refreshRate) {
      return window.setInterval(function() {
        return _this.update();
      }, refreshRate);
    })(this, this.config.refreshRate);
  };

  KelviTopic.prototype.encodedCallbackName = function() {
    var callback_topic, match, matches, _i, _len;
    callback_topic = this.topic;
    matches = callback_topic.match(/[$%#.+-]/g) || [];
    for (_i = 0, _len = matches.length; _i < _len; _i++) {
      match = matches[_i];
      callback_topic = callback_topic.replace(match, SYMBOL_CODE_MAP[match]);
      console.log("matches", match, callback_topic);
    }
    return callback_topic;
  };

  KelviTopic.prototype.update = function() {
    var encodedTopic, url, watchCfg, _i, _len, _ref1;
    _ref1 = this._watches;
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      watchCfg = _ref1[_i];
      url = this.getURL(watchCfg);
      encodedTopic = encodeURIComponent(this.topic);
      url = "" + url + "callback=JSON_CALLBACK&jsonp=callback_" + (this.encodedCallbackName()) + "_" + watchCfg.category;
      if (this.dataLoader && typeof this.dataLoader === 'function') {
        if (this.dataloadInit && typeof this.dataloadInit === 'function') {
          this.dataloadInit();
        }
        this.dataLoader(url);
      }
    }
  };

  return KelviTopic;

})(Panel);

/*
Defines various custom events
	- Loops
*/


angular.module('CustomEvents', []).directive('loopEvents', function() {
  return function(scope, element, attrs) {
    if (scope.$first) {
      scope.$emit("ng-repeat:start", {
        "element": element[0],
        "attrs": attrs
      });
    }
    if (scope.$last) {
      scope.$emit("ng-repeat:complete", {
        "element": element[0],
        "attrs": attrs
      });
    }
  };
});

/*
	Load custom events for event handling
*/


Kelvi = angular.module('Kelvi', ['CustomEvents']);

Kelvi.controller('KelviController', function($scope, $http) {
  var _this = this;
  $scope.SO_URL = 'https://stackoverflow.com';
  $scope.$on("ng-repeat:complete", function() {
    return $scope.changeHeight();
  });
  $scope.SETTINGS = GlobalConfig;
  $scope.panels = [];
  /* Setup shortcuts*/

  $scope.get = function(prop) {
    return $scope.SETTINGS[prop] || null;
  };
  $scope.topics = function() {
    return GlobalConfig.topics;
  };
  $scope.dashboard = new KelviDashboard("Stacks");
  $scope.addTopic = function(topic) {
    var panel;
    panel = new KelviTopic(topic);
    panel.dataLoader = function(url) {
      return $http.jsonp(url);
    };
    return $scope.dashboard.addPanel(panel);
  };
  $scope.questions_watch = function(panel, watch) {
    return panel.questions(watch.category);
  };
  $scope.questions = function(panel) {
    var watch, _i, _len, _ref1;
    _ref1 = panel.watches();
    for (_i = 0, _len = _ref1.length; _i < _len; _i++) {
      watch = _ref1[_i];
      if (watch.show) {
        return panel.questions(watch.category);
      }
    }
  };
  $scope.changeHeight = function() {
    var h, max;
    max = -999999;
    $(".topic").each(function(k, o) {
      $(o).css('height', '100%');
      return max = Math.max(max, $(o).height());
    });
    h = max < ($scope.SETTINGS.questionsCount * 50) ? ($scope.SETTINGS.questionsCount * 45) + "px" : max;
    $(".topic").height(h);
  };
  $(window).resize($scope.changeHeight);
  $scope.init = function() {
    var cfg, topic, _ref1;
    console.log($scope.topics());
    _ref1 = $scope.topics();
    for (topic in _ref1) {
      cfg = _ref1[topic];
      $scope.addTopic(topic);
    }
    $scope.panels = $scope.dashboard.get("panels");
  };
  $scope.new_data = function(data, topic) {
    $scope.$emit("Kelvi:update", {
      "data": data,
      "topic": topic
    });
    return this;
  };
  $scope.addNewTopic = function() {
    var topics;
    topics = $scope.SETTINGS.topics;
    if (topics.indexOf($scope.newTopic) > -1) {

    } else {
      return topics.push($scope.newTopic);
    }
  };
  $scope.removeTopic = function(item) {
    var topics;
    topics = $scope.SETTINGS.topics;
    topics.splice(topics.indexOf(item), 1);
  };
});

Kelvi.controller('KelviConfigController', function($scope, $http) {
  $scope.topics = function() {
    return GlobalConfig.topics;
  };
  $scope.addNewTopic = function() {
    updateConfig($scope.newTopic);
    return $scope.newTopic = '';
  };
  $scope.removeTopic = function(topic) {
    delete GlobalConfig.topics[topic];
    return saveConfig();
  };
  $scope.watchesAvailable = function(topic) {
    var k, watch, watches, _ref1;
    watches = [];
    _ref1 = GlobalConfig.topics[topic].watches;
    for (k in _ref1) {
      watch = _ref1[k];
      if (watch.enable) {
        watches.push(watch);
      }
    }
    return watches;
  };
  $scope.getHttpCallsFreq = function() {
    var cfg, count, freq, freq1, topic, watchesCount, _ref1;
    count = 0;
    freq = 0;
    _ref1 = GlobalConfig.topics;
    for (topic in _ref1) {
      cfg = _ref1[topic];
      watchesCount = $scope.watchesAvailable(topic).length;
      freq1 = watchesCount * (1000 * 60 * 60) / parseInt(GlobalConfig.topics[topic].refreshRate);
      freq1 = freq1 / 60;
      count += watchesCount;
      freq += freq1;
    }
    return {
      'count': count,
      'freq': freq
    };
  };
  $scope.config = function(topic) {
    return GlobalConfig.topics[topic];
  };
  $scope.saveConfig = function() {
    return saveConfig();
  };
  return $scope.decideWatchToShow = function(topic, watch) {
    var watches;
    watches = $scope.watchesAvailable(topic);
    if (watch.enable) {
      watches[1].show = false;
    } else if (!watch.enable) {
      watches[0].show = true;
    }
    return watch.show = watch.enable;
  };
});
